<?php
/**
 * MagedIn Technology
 *
 * Do not edit this file if you want to update this module for future new versions.
 *
 * @category  MagedIn
 * @copyright Copyright (c) 2024 MagedIn Technology.
 *
 * @author    MagedIn Support <support@magedin.com>
 */

declare(strict_types=1);

namespace MagedIn\Framework\Magento2;

/**
 * DocBlock for Profiler class.
 */
class Profiler
{
    public const CHARS_LOWERS = 'abcdefghijklmnopqrstuvwxyz';

    public const CHARS_UPPERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    public const CHARS_DIGITS = '0123456789';

    public const MEMORY_FORMAT_BYTES = 0;
    public const MEMORY_FORMAT_KB = 1;
    public const MEMORY_FORMAT_MB = 2;
    public const MEMORY_FORMAT_GB = 3;

    /**
     * @var array
     */
    private static array $timer = [];
    /**
     * @var array
     */
    private static array $memory = [];

    /**
     * DocBlock for method.
     *
     * @param int $length
     *
     * @return string
     */
    public static function generateKey(int $length = 32): string
    {
        $str = '';
        $chars = self::CHARS_LOWERS.self::CHARS_UPPERS.self::CHARS_DIGITS;

        $charsMaxKey = mb_strlen($chars) - 1;
        for ($i = 0; $i < $length; $i++) {
            $str .= $chars[random_int(0, $charsMaxKey)];
        }
        return $str;
    }

    /**
     * DocBlock for method.
     *
     * @param string|null $name
     *
     * @return string
     */
    public static function start(string $name = null): string
    {
        if (empty($name)) {
            $name = self::generateKey();
        }
        self::reset($name);
        self::$timer[$name]['start'] = microtime(true);
        self::$memory[$name]['start'] = memory_get_usage();
        return $name;
    }

    /**
     * DocBlock for method.
     *
     * @param string $name
     *
     * @return void
     */
    public static function stop(string $name): void
    {
        self::$timer[$name]['end'] = microtime(true);
        $startTime = self::$timer[$name]['start'] ?? 0;
        $endTime = self::$timer[$name]['end'] ?? 0;
        self::$timer[$name]['duration'] = $endTime - $startTime;

        self::$memory[$name]['end'] = memory_get_peak_usage();
        $startMemory = self::$memory[$name]['start'] ?? 0;
        $endMemory = self::$memory[$name]['end'] ?? 0;
        self::$memory[$name]['used'] = $endMemory - $startMemory;
    }

    /**
     * DocBlock for method.
     *
     * @param string|null $name
     *
     * @return void
     */
    public static function reset(string $name = null): void
    {
        if ($name === null) {
            self::$timer = [];
            self::$memory = [];
        } else {
            self::$timer[$name] = [];
            self::$memory[$name] = [];
        }
    }

    /**
     * DocBlock for method.
     *
     * @param string $name
     *
     * @return float
     */
    public static function getDuration(string $name): float
    {
        if (empty(self::$timer[$name]['duration'])) {
            self::stop($name);
        }
        return self::$timer[$name]['duration'] ?? 0;
    }

    /**
     * DocBlock for method.
     *
     * @param string $name
     * @param int $format
     *
     * @return float
     */
    public static function getMemory(string $name, int $format = self::MEMORY_FORMAT_BYTES): float
    {
        if (empty(self::$memory[$name]['used'])) {
            self::stop($name);
        }
        $result = self::$memory[$name]['used'] ?? 0;
        for ($i = 0; $i < $format; $i++) {
            $result = $result / 1024;
        }
        return $result;
    }
}
