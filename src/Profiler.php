<?php
/**
 * MagedIn Technology
 *
 * Do not edit this file if you want to update this module for future new versions.
 *
 * @category  MagedIn
 * @copyright Copyright (c) 2025 MagedIn Technology.
 *
 * @author    MagedIn Support <support@magedin.com>
 */

declare(strict_types=1);

namespace MagedIn\Framework\Magento2;

/**
 * Profiler class for tracking execution time and memory usage.
 */
class Profiler
{
    /**
     * Lowercase alphabet characters.
     */
    public const CHARS_LOWERS = 'abcdefghijklmnopqrstuvwxyz';

    /**
     * Uppercase alphabet characters.
     */
    public const CHARS_UPPERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    /**
     * Numeric characters.
     */
    public const CHARS_DIGITS = '0123456789';

    /**
     * Memory format constants.
     */
    public const MEMORY_FORMAT_BYTES = 0;
    public const MEMORY_FORMAT_KB = 1;
    public const MEMORY_FORMAT_MB = 2;
    public const MEMORY_FORMAT_GB = 3;

    /**
     * Timer data storage.
     *
     * @var array
     */
    private static array $timer = [];

    /**
     * Memory usage data storage.
     *
     * @var array
     */
    private static array $memory = [];

    /**
     * Generates a random key of the specified length.
     *
     * @param int $length Length of the key to generate. Default is 32.
     *
     * @return string The generated key.
     */
    public static function generateKey(int $length = 32): string
    {
        $str = '';
        $chars = self::CHARS_LOWERS.self::CHARS_UPPERS.self::CHARS_DIGITS;

        $charsMaxKey = mb_strlen($chars) - 1;
        for ($i = 0; $i < $length; $i++) {
            $str .= $chars[random_int(0, $charsMaxKey)];
        }
        return $str;
    }

    /**
     * Starts profiling for a given name or generates a new key if none is provided.
     *
     * @param string|null $name Optional name for the profiling session.
     *
     * @return string The name of the profiling session.
     */
    public static function start(string $name = null): string
    {
        if (empty($name)) {
            $name = self::generateKey();
        }
        self::reset($name);
        self::$timer[$name]['start'] = microtime(true);
        self::$memory[$name]['start'] = memory_get_usage();
        return $name;
    }

    /**
     * Stops profiling for a given name and calculates duration and memory usage.
     *
     * @param string $name The name of the profiling session.
     *
     * @return void
     */
    public static function stop(string $name): void
    {
        self::$timer[$name]['end'] = microtime(true);
        $startTime = self::$timer[$name]['start'] ?? 0;
        $endTime = self::$timer[$name]['end'] ?? 0;
        self::$timer[$name]['duration'] = $endTime - $startTime;

        self::$memory[$name]['end'] = memory_get_peak_usage();
        $startMemory = self::$memory[$name]['start'] ?? 0;
        $endMemory = self::$memory[$name]['end'] ?? 0;
        self::$memory[$name]['used'] = $endMemory - $startMemory;
    }

    /**
     * Resets profiling data for a given name or all sessions if no name is provided.
     *
     * @param string|null $name Optional name of the profiling session to reset.
     *
     * @return void
     */
    public static function reset(string $name = null): void
    {
        if ($name === null) {
            self::$timer = [];
            self::$memory = [];
        } else {
            self::$timer[$name] = [];
            self::$memory[$name] = [];
        }
    }

    /**
     * Retrieves the duration of a profiling session.
     *
     * @param string $name The name of the profiling session.
     *
     * @return float The duration in seconds.
     */
    public static function getDuration(string $name): float
    {
        if (empty(self::$timer[$name]['duration'])) {
            self::stop($name);
        }
        return self::$timer[$name]['duration'] ?? 0;
    }

    /**
     * Retrieves the memory usage of a profiling session in the specified format.
     *
     * @param string $name The name of the profiling session.
     * @param int $format The memory format (e.g., bytes, KB, MB, GB). Default is bytes.
     *
     * @return float The memory usage in the specified format.
     */
    public static function getMemory(string $name, int $format = self::MEMORY_FORMAT_BYTES): float
    {
        if (empty(self::$memory[$name]['used'])) {
            self::stop($name);
        }
        $result = self::$memory[$name]['used'] ?? 0;
        for ($i = 0; $i < $format; $i++) {
            $result = $result / 1024;
        }
        return $result;
    }
}
