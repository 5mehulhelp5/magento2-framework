<?php
/**
 * MagedIn Technology
 *
 * Do not edit this file if you want to update this module for future new versions.
 *
 * @category  MagedIn
 * @copyright Copyright (c) 2025 MagedIn Technology.
 *
 * @author    MagedIn Support <support@magedin.com>
 */

declare(strict_types=1);

namespace MagedIn\Framework\Magento2\Validator;

/**
 * Class CronExpression
 *
 * Validates cron expressions according to standard cron format.
 * Supports 5-field format: minute hour day month weekday
 *
 * Validation Rules:
 * - Minute: 0-59
 * - Hour: 0-23
 * - Day of Month: 1-31
 * - Month: 1-12
 * - Day of Week: 0-7 (0 and 7 are Sunday)
 *
 * Special Characters:
 * - * (asterisk): matches all values
 * - , (comma): separates multiple values
 * - - (hyphen): defines ranges
 * - / (slash): defines step values
 * - ? (question mark): no specific value (only for day fields)
 */
class CronExpression
{
    /**
     * Field position constants
     */
    private const MINUTE = 0;
    private const HOUR = 1;
    private const DAY_OF_MONTH = 2;
    private const MONTH = 3;
    private const DAY_OF_WEEK = 4;

    /**
     * Field validation ranges
     */
    private const FIELD_RANGES = [
        self::MINUTE => ['min' => 0, 'max' => 59],
        self::HOUR => ['min' => 0, 'max' => 23],
        self::DAY_OF_MONTH => ['min' => 1, 'max' => 31],
        self::MONTH => ['min' => 1, 'max' => 12],
        self::DAY_OF_WEEK => ['min' => 0, 'max' => 7],
    ];

    /**
     * Field names for error reporting
     */
    private const FIELD_NAMES = [
        self::MINUTE => 'minute',
        self::HOUR => 'hour',
        self::DAY_OF_MONTH => 'day of month',
        self::MONTH => 'month',
        self::DAY_OF_WEEK => 'day of week',
    ];

    /**
     * Special characters allowed in cron expressions
     */
    private const SPECIAL_CHARS = ['*', ',', '-', '/', '?'];

    /**
     * Month name aliases
     */
    private const MONTH_ALIASES = [
        'jan' => 1, 'feb' => 2, 'mar' => 3, 'apr' => 4, 'may' => 5, 'jun' => 6,
        'jul' => 7, 'aug' => 8, 'sep' => 9, 'oct' => 10, 'nov' => 11, 'dec' => 12,
    ];

    /**
     * Day of week name aliases
     */
    private const DAY_ALIASES = [
        'sun' => 0, 'mon' => 1, 'tue' => 2, 'wed' => 3,
        'thu' => 4, 'fri' => 5, 'sat' => 6,
    ];

    /**
     * Validation error messages
     */
    private array $errors = [];

    /**
     * Validate a cron expression
     *
     * @param string $expression The cron expression to validate
     *
     * @return bool True if valid, false otherwise
     */
    public function validate(string $expression): bool
    {
        $this->errors = [];

        if (empty(trim($expression))) {
            $this->addError('Cron expression cannot be empty');
            return false;
        }

        // Split expression into fields
        $fields = $this->parseExpression($expression);

        if ($fields === null) {
            return false;
        }

        // Validate each field
        foreach ($fields as $position => $field) {
            $this->validateField($field, $position);
        }

        return empty($this->errors);
    }

    /**
     * Get validation error messages
     *
     * @return array Array of error messages
     */
    public function getErrors(): array
    {
        return $this->errors;
    }

    /**
     * Get the last validation error message
     *
     * @return string|null Last error message or null if no errors
     */
    public function getLastError(): ?string
    {
        return end($this->errors) ?: null;
    }

    /**
     * Check if expression is valid (alias for validate)
     *
     * @param string $expression
     *
     * @return bool
     */
    public function isValid(string $expression): bool
    {
        return $this->validate($expression);
    }

    /**
     * Parse cron expression into fields
     *
     * @param string $expression
     *
     * @return array|null Array of fields or null if invalid format
     */
    private function parseExpression(string $expression): ?array
    {
        // Clean and split expression
        $expression = trim($expression);
        $fields = preg_split('/\s+/', $expression);

        // Must have exactly 5 fields
        if (count($fields) !== 5) {
            $this->addError(sprintf(
                'Invalid cron expression format. Expected 5 fields, got %d',
                count($fields)
            ));
            return null;
        }

        return $fields;
    }

    /**
     * Validate a single field
     *
     * @param string $field Field value to validate
     * @param int $position Field position (0-4)
     *
     * @return void
     */
    private function validateField(string $field, int $position): void
    {
        $fieldName = self::FIELD_NAMES[$position];

        // Replace aliases with numeric values
        $field = $this->replaceAliases($field, $position);

        // Handle special cases
        if ($field === '*') {
            return; // Wildcard is always valid
        }

        if ($field === '?') {
            if ($position !== self::DAY_OF_MONTH && $position !== self::DAY_OF_WEEK) {
                $this->addError("Question mark (?) can only be used in day of month or day of week fields");
                return;
            }
            return;
        }

        // Validate complex expressions
        $this->validateComplexField($field, $position, $fieldName);
    }

    /**
     * Validate complex field expressions (ranges, lists, steps)
     *
     * @param string $field Field value
     * @param int $position Field position
     * @param string $fieldName Field name for errors
     *
     * @return void
     */
    private function validateComplexField(string $field, int $position, string $fieldName): void
    {
        // Handle comma-separated lists
        if (strpos($field, ',') !== false) {
            $values = explode(',', $field);
            foreach ($values as $value) {
                $this->validateComplexField(trim($value), $position, $fieldName);
            }
            return;
        }

        // Handle step values (e.g., */5, 1-10/2)
        if (strpos($field, '/') !== false) {
            $this->validateStepExpression($field, $position, $fieldName);
            return;
        }

        // Handle ranges (e.g., 1-5)
        if (strpos($field, '-') !== false) {
            $this->validateRangeExpression($field, $position, $fieldName);
            return;
        }

        // Validate single numeric value
        $this->validateNumericValue($field, $position, $fieldName);
    }

    /**
     * Validate step expressions (e.g., asterisk/5, 1-10/2)
     *
     * @param string $field Field value
     * @param int $position Field position
     * @param string $fieldName Field name for errors
     *
     * @return void
     */
    private function validateStepExpression(string $field, int $position, string $fieldName): void
    {
        $parts = explode('/', $field, 2);

        if (count($parts) !== 2) {
            $this->addError("Invalid step expression in {$fieldName}: {$field}");
            return;
        }

        [$range, $step] = $parts;

        // Validate step value
        if (!ctype_digit($step) || (int) $step <= 0) {
            $this->addError("Invalid step value in {$fieldName}: {$step}");
            return;
        }

        // Validate range part
        if ($range === '*') {
            return; // */n is valid
        }

        if (strpos($range, '-') !== false) {
            $this->validateRangeExpression($range, $position, $fieldName);
        } else {
            $this->validateNumericValue($range, $position, $fieldName);
        }
    }

    /**
     * Validate range expressions (e.g., 1-5)
     *
     * @param string $field Field value
     * @param int $position Field position
     * @param string $fieldName Field name for errors
     *
     * @return void
     */
    private function validateRangeExpression(string $field, int $position, string $fieldName): void
    {
        $parts = explode('-', $field, 2);

        if (count($parts) !== 2) {
            $this->addError("Invalid range expression in {$fieldName}: {$field}");
            return;
        }

        [$start, $end] = $parts;

        // Validate both range endpoints
        $this->validateNumericValue($start, $position, $fieldName);
        $this->validateNumericValue($end, $position, $fieldName);

        // Check if range is logical
        if (is_numeric($start) && is_numeric($end) && (int) $start > (int) $end) {
            $this->addError("Invalid range in {$fieldName}: start ({$start}) cannot be greater than end ({$end})");
        }
    }

    /**
     * Validate numeric value
     *
     * @param string $value Value to validate
     * @param int $position Field position
     * @param string $fieldName Field name for errors
     *
     * @return void
     */
    private function validateNumericValue(string $value, int $position, string $fieldName): void
    {
        if (!ctype_digit($value)) {
            $this->addError("Invalid numeric value in {$fieldName}: {$value}");
            return;
        }

        $numValue = (int) $value;
        $range = self::FIELD_RANGES[$position];

        // Special case for day of week: both 0 and 7 represent Sunday
        if ($position === self::DAY_OF_WEEK && $numValue === 7) {
            $numValue = 0;
        }

        if ($numValue < $range['min'] || $numValue > $range['max']) {
            $this->addError(sprintf(
                "Value %d is out of range for %s (valid range: %d-%d)",
                $numValue,
                $fieldName,
                $range['min'],
                $range['max']
            ));
        }
    }

    /**
     * Replace month and day aliases with numeric values
     *
     * @param string $field Field value
     * @param int $position Field position
     *
     * @return string Field with aliases replaced
     */
    private function replaceAliases(string $field, int $position): string
    {
        if ($position === self::MONTH) {
            return str_ireplace(
                array_keys(self::MONTH_ALIASES),
                array_values(self::MONTH_ALIASES),
                strtolower($field)
            );
        }

        if ($position === self::DAY_OF_WEEK) {
            return str_ireplace(
                array_keys(self::DAY_ALIASES),
                array_values(self::DAY_ALIASES),
                strtolower($field)
            );
        }

        return $field;
    }

    /**
     * Add validation error message
     *
     * @param string $message Error message
     *
     * @return void
     */
    private function addError(string $message): void
    {
        $this->errors[] = $message;
    }
}
