<?php
/**
 * MagedIn Technology
 *
 * Do not edit this file if you want to update this module for future new versions.
 *
 * @category  MagedIn
 * @copyright Copyright (c) 2025 MagedIn Technology.
 *
 * @author    MagedIn Support <support@magedin.com>
 */

declare(strict_types=1);

namespace Validator;

use MagedIn\Framework\Magento2\Validator\CronExpression;
use PHPUnit\Framework\TestCase;

/**
 * Class CronExpressionTest
 *
 * Unit tests for the CronExpression validator.
 * Tests various cron expression formats and edge cases.
 */
class CronExpressionTest extends TestCase
{
    /**
     * @var CronExpression
     */
    private CronExpression $validator;

    /**
     * Set up test fixture
     */
    protected function setUp(): void
    {
        $this->validator = new CronExpression();
    }

    /**
     * Test valid basic cron expressions
     *
     * @dataProvider validBasicExpressionsProvider
     */
    public function testValidBasicExpressions(string $expression): void
    {
        $this->assertTrue($this->validator->validate($expression));
        $this->assertEmpty($this->validator->getErrors());
    }

    /**
     * Test valid complex cron expressions
     *
     * @dataProvider validComplexExpressionsProvider
     */
    public function testValidComplexExpressions(string $expression): void
    {
        $this->assertTrue($this->validator->validate($expression));
        $this->assertEmpty($this->validator->getErrors());
    }

    /**
     * Test invalid cron expressions
     *
     * @dataProvider invalidExpressionsProvider
     */
    public function testInvalidExpressions(string $expression, string $expectedErrorKeyword): void
    {
        $this->assertFalse($this->validator->validate($expression));
        $errors = $this->validator->getErrors();
        $this->assertNotEmpty($errors);

        // Check that error message contains expected keyword
        $errorString = implode(' ', $errors);
        $this->assertStringContainsStringIgnoringCase($expectedErrorKeyword, $errorString);
    }

    /**
     * Test expressions with month aliases
     */
    public function testMonthAliases(): void
    {
        $validExpressions = [
            '0 0 1 jan *',
            '0 0 15 feb *',
            '30 12 * mar 1',
            '45 23 31 dec 0'
        ];

        foreach ($validExpressions as $expression) {
            $this->assertTrue($this->validator->validate($expression), "Failed for: {$expression}");
        }
    }

    /**
     * Test expressions with day aliases
     */
    public function testDayAliases(): void
    {
        $validExpressions = [
            '0 9 * * mon',
            '30 17 * * tue',
            '0 0 * * sun',
            '15 12 * * sat'
        ];

        foreach ($validExpressions as $expression) {
            $this->assertTrue($this->validator->validate($expression), "Failed for: {$expression}");
        }
    }

    /**
     * Test step expressions
     */
    public function testStepExpressions(): void
    {
        $validExpressions = [
            '*/5 * * * *',      // Every 5 minutes
            '0 */2 * * *',      // Every 2 hours
            '0 0 */3 * *',      // Every 3 days
            '0 0 1 */2 *',      // Every 2 months
            '0 0 * * */2',      // Every 2 days of week
            '5-25/5 * * * *',   // Every 5 minutes from 5 to 25
            '10-50/10 * * * *'  // Every 10 minutes from 10 to 50
        ];

        foreach ($validExpressions as $expression) {
            $this->assertTrue($this->validator->validate($expression), "Failed for: {$expression}");
        }

        // Invalid step expressions
        $invalidExpressions = [
            '*/0 * * * *',      // Step cannot be 0
            '*/60 * * * *',     // Step too large for minutes
            '0 */25 * * *',     // Step too large for hours
            '5-/5 * * * *',     // Invalid range format
        ];

        foreach ($invalidExpressions as $expression) {
            $this->assertFalse($this->validator->validate($expression), "Should fail for: {$expression}");
        }
    }

    /**
     * Test range expressions
     */
    public function testRangeExpressions(): void
    {
        $validExpressions = [
            '0-30 * * * *',     // Minutes 0 to 30
            '* 9-17 * * *',     // Hours 9 to 17
            '* * 1-15 * *',     // Days 1 to 15
            '* * * 6-8 *',      // Months 6 to 8 (Jun-Aug)
            '* * * * 1-5'       // Monday to Friday
        ];

        foreach ($validExpressions as $expression) {
            $this->assertTrue($this->validator->validate($expression), "Failed for: {$expression}");
        }

        // Invalid range expressions
        $invalidExpressions = [
            '30-10 * * * *',    // Start > End
            '* 25-30 * * *',    // Hours out of range
            '* * 40-50 * *',    // Days out of range
            '* * * 13-15 *',    // Months out of range
            '* * * * 8-10'      // Days of week out of range
        ];

        foreach ($invalidExpressions as $expression) {
            $this->assertFalse($this->validator->validate($expression), "Should fail for: {$expression}");
        }
    }

    /**
     * Test list expressions (comma-separated values)
     */
    public function testListExpressions(): void
    {
        $validExpressions = [
            '0,15,30,45 * * * *',   // Multiple minutes
            '* 8,12,18 * * *',      // Multiple hours
            '* * 1,15,30 * *',      // Multiple days
            '* * * 1,6,12 *',       // Multiple months
            '* * * * 1,3,5'         // Multiple weekdays
        ];

        foreach ($validExpressions as $expression) {
            $this->assertTrue($this->validator->validate($expression), "Failed for: {$expression}");
        }
    }

    /**
     * Test question mark usage
     */
    public function testQuestionMarkUsage(): void
    {
        // Valid usage (only in day fields)
        $validExpressions = [
            '0 0 ? * 1',    // Question mark in day of month
            '0 0 1 * ?'     // Question mark in day of week
        ];

        foreach ($validExpressions as $expression) {
            $this->assertTrue($this->validator->validate($expression), "Failed for: {$expression}");
        }

        // Invalid usage (in other fields)
        $invalidExpressions = [
            '? * * * *',    // Question mark in minute
            '* ? * * *',    // Question mark in hour
            '* * * ? *'     // Question mark in month
        ];

        foreach ($invalidExpressions as $expression) {
            $this->assertFalse($this->validator->validate($expression), "Should fail for: {$expression}");
        }
    }

    /**
     * Test edge cases and special values
     */
    public function testEdgeCases(): void
    {
        // Test Sunday as both 0 and 7
        $this->assertTrue($this->validator->validate('0 0 * * 0'));  // Sunday as 0
        $this->assertTrue($this->validator->validate('0 0 * * 7'));  // Sunday as 7

        // Test empty and whitespace
        $this->assertFalse($this->validator->validate(''));
        $this->assertFalse($this->validator->validate('   '));
        $this->assertFalse($this->validator->validate("\t\n"));
    }

    /**
     * Test error message functionality
     */
    public function testErrorMessages(): void
    {
        // Test getting errors
        $this->validator->validate('invalid expression');
        $errors = $this->validator->getErrors();
        $this->assertNotEmpty($errors);
        $this->assertIsArray($errors);

        // Test getting last error
        $lastError = $this->validator->getLastError();
        $this->assertNotNull($lastError);
        $this->assertIsString($lastError);

        // Test no errors on valid expression
        $this->validator->validate('0 0 * * *');
        $this->assertEmpty($this->validator->getErrors());
        $this->assertNull($this->validator->getLastError());
    }

    /**
     * Test isValid alias method
     */
    public function testIsValidAlias(): void
    {
        $this->assertTrue($this->validator->isValid('0 0 * * *'));
        $this->assertFalse($this->validator->isValid('invalid'));
    }

    /**
     * Data provider for valid basic expressions
     */
    public function validBasicExpressionsProvider(): array
    {
        return [
            ['0 0 * * *'],          // Daily at midnight
            ['*/5 * * * *'],        // Every 5 minutes
            ['0 */2 * * *'],        // Every 2 hours
            ['0 0 1 * *'],          // First day of every month
            ['0 0 * * 0'],          // Every Sunday
            ['30 8 * * 1-5'],       // Weekdays at 8:30 AM
            ['0 12 * * *'],         // Daily at noon
            ['15 3 * * *'],         // Daily at 3:15 AM
            ['0 0 1 1 *'],          // New Year's Day
            ['59 23 31 12 *']       // Last minute of year
        ];
    }

    /**
     * Data provider for valid complex expressions
     */
    public function validComplexExpressionsProvider(): array
    {
        return [
            ['0,15,30,45 * * * *'],     // Every 15 minutes
            ['0 8,12,18 * * *'],        // Three times a day
            ['0 0 1,15 * *'],           // Twice a month
            ['0 0 * 1,6,12 *'],         // Every 6 months
            ['0 9-17 * * 1-5'],         // Business hours, weekdays
            ['*/10 9-17 * * 1-5'],      // Every 10 min, business hours
            ['0 0 1-7 * 1'],            // First Monday of month
            ['30 */3 * * *'],           // Every 3 hours at half past
            ['0 2 */2 * *'],            // Every other day at 2 AM
            ['0 0 1 */3 *']             // Every quarter (every 3 months)
        ];
    }

    /**
     * Data provider for invalid expressions
     */
    public function invalidExpressionsProvider(): array
    {
        return [
            ['* * * *', 'Expected 5 fields'],              // Too few fields
            ['* * * * * *', 'Expected 5 fields'],          // Too many fields
            ['60 * * * *', 'out of range'],                // Minutes out of range
            ['* 24 * * *', 'out of range'],                // Hours out of range
            ['* * 0 * *', 'out of range'],                 // Day of month out of range
            ['* * 32 * *', 'out of range'],                // Day of month out of range
            ['* * * 0 *', 'out of range'],                 // Month out of range
            ['* * * 13 *', 'out of range'],                // Month out of range
            ['* * * * 8', 'out of range'],                 // Day of week out of range
            ['abc * * * *', 'Invalid numeric'],            // Non-numeric value
            ['* def * * *', 'Invalid numeric'],            // Non-numeric value
            ['? * * * *', 'Question mark'],                // Question mark in wrong field
            ['*/0 * * * *', 'Invalid step'],               // Zero step
            ['/5 * * * *', 'Invalid step'],                // Missing range before step
            ['1-60 * * * *', 'out of range'],              // Range end out of bounds
            ['30-10 * * * *', 'start'],                    // Invalid range (start > end)
            ['1--5 * * * *', 'Invalid range'],             // Double dash
            ['1- * * * *', 'Invalid range'],               // Incomplete range
            ['-5 * * * *', 'Invalid numeric'],             // Range starting with dash
        ];
    }
}
